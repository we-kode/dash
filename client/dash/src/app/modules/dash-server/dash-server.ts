//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const DASH_SERVER_API_BASE_URL = new InjectionToken<string>('DASH_SERVER_API_BASE_URL');

export interface IDashServerCalendar {
    get(id: string): Observable<DashServerApiResponse<Calendar>>;
    update(id: string, req: CalendarRequest): Observable<DashServerApiResponse<FileResponse>>;
    delete(id: string): Observable<DashServerApiResponse<FileResponse>>;
    getAll(): Observable<DashServerApiResponse<Calendar[]>>;
    create(req: CalendarRequest): Observable<DashServerApiResponse<FileResponse>>;
    getEvent(id: string): Observable<DashServerApiResponse<CalendarEvent>>;
    updateEvent(id: string, req: CalendarEventRequest): Observable<DashServerApiResponse<FileResponse>>;
    deleteEvent(id: string): Observable<DashServerApiResponse<FileResponse>>;
    createEvent(req: CalendarEventRequest): Observable<DashServerApiResponse<FileResponse>>;
    getEvents(start: Date | undefined, end: Date | undefined): Observable<DashServerApiResponse<CalendarEvent[]>>;
}

@Injectable()
export class DashServerCalendar implements IDashServerCalendar {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DASH_SERVER_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    get(id: string): Observable<DashServerApiResponse<Calendar>> {
        let url_ = this.baseUrl + "/api/Calendar/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<Calendar>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<Calendar>>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DashServerApiResponse<Calendar>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Calendar.fromJS(resultData200);
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<Calendar>>(new DashServerApiResponse(status, _headers, null as any));
    }

    update(id: string, req: CalendarRequest): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Calendar/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    delete(id: string): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Calendar/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    getAll(): Observable<DashServerApiResponse<Calendar[]>> {
        let url_ = this.baseUrl + "/api/Calendar";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<Calendar[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<Calendar[]>>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DashServerApiResponse<Calendar[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Calendar.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<Calendar[]>>(new DashServerApiResponse(status, _headers, null as any));
    }

    create(req: CalendarRequest): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Calendar";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    getEvent(id: string): Observable<DashServerApiResponse<CalendarEvent>> {
        let url_ = this.baseUrl + "/api/Calendar/event/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<CalendarEvent>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<CalendarEvent>>;
        }));
    }

    protected processGetEvent(response: HttpResponseBase): Observable<DashServerApiResponse<CalendarEvent>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CalendarEvent.fromJS(resultData200);
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<CalendarEvent>>(new DashServerApiResponse(status, _headers, null as any));
    }

    updateEvent(id: string, req: CalendarEventRequest): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Calendar/event/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processUpdateEvent(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    deleteEvent(id: string): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Calendar/event/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processDeleteEvent(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    createEvent(req: CalendarEventRequest): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Calendar/event";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processCreateEvent(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    getEvents(start: Date | undefined, end: Date | undefined): Observable<DashServerApiResponse<CalendarEvent[]>> {
        let url_ = this.baseUrl + "/api/Calendar/events?";
        if (start === null)
            throw new Error("The parameter 'start' cannot be null.");
        else if (start !== undefined)
            url_ += "start=" + encodeURIComponent(start ? "" + start.toISOString() : "") + "&";
        if (end === null)
            throw new Error("The parameter 'end' cannot be null.");
        else if (end !== undefined)
            url_ += "end=" + encodeURIComponent(end ? "" + end.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEvents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEvents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<CalendarEvent[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<CalendarEvent[]>>;
        }));
    }

    protected processGetEvents(response: HttpResponseBase): Observable<DashServerApiResponse<CalendarEvent[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CalendarEvent.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<CalendarEvent[]>>(new DashServerApiResponse(status, _headers, null as any));
    }
}

export interface IDashServerDisplay {
    refresh(id: string): Observable<DashServerApiResponse<FileResponse>>;
    update(display: Display): Observable<DashServerApiResponse<FileResponse>>;
    edit(): Observable<DashServerApiResponse<Display>>;
    get(shareId: string): Observable<DashServerApiResponse<Display>>;
}

@Injectable()
export class DashServerDisplay implements IDashServerDisplay {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DASH_SERVER_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    refresh(id: string): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Display/refresh/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processRefresh(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    update(display: Display): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Display";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(display);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    edit(): Observable<DashServerApiResponse<Display>> {
        let url_ = this.baseUrl + "/api/Display/Edit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<Display>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<Display>>;
        }));
    }

    protected processEdit(response: HttpResponseBase): Observable<DashServerApiResponse<Display>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Display.fromJS(resultData200);
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<Display>>(new DashServerApiResponse(status, _headers, null as any));
    }

    get(shareId: string): Observable<DashServerApiResponse<Display>> {
        let url_ = this.baseUrl + "/api/Display/{shareId}";
        if (shareId === undefined || shareId === null)
            throw new Error("The parameter 'shareId' must be defined.");
        url_ = url_.replace("{shareId}", encodeURIComponent("" + shareId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<Display>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<Display>>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DashServerApiResponse<Display>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Display.fromJS(resultData200);
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<Display>>(new DashServerApiResponse(status, _headers, null as any));
    }
}

export interface IDashServerElement {
    create(req: ElementRequest): Observable<DashServerApiResponse<FileResponse>>;
    update(id: string, req: ElementRequest): Observable<DashServerApiResponse<FileResponse>>;
    delete(id: string, displayId: string): Observable<DashServerApiResponse<FileResponse>>;
    getByDisplay(displayId: string): Observable<DashServerApiResponse<Element[]>>;
    components(): Observable<DashServerApiResponse<Component[]>>;
}

@Injectable()
export class DashServerElement implements IDashServerElement {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DASH_SERVER_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(req: ElementRequest): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Element";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    update(id: string, req: ElementRequest): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Element/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(req);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    delete(id: string, displayId: string): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Element/{id}/{displayId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (displayId === undefined || displayId === null)
            throw new Error("The parameter 'displayId' must be defined.");
        url_ = url_.replace("{displayId}", encodeURIComponent("" + displayId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    getByDisplay(displayId: string): Observable<DashServerApiResponse<Element[]>> {
        let url_ = this.baseUrl + "/api/Element/{displayId}";
        if (displayId === undefined || displayId === null)
            throw new Error("The parameter 'displayId' must be defined.");
        url_ = url_.replace("{displayId}", encodeURIComponent("" + displayId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByDisplay(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByDisplay(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<Element[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<Element[]>>;
        }));
    }

    protected processGetByDisplay(response: HttpResponseBase): Observable<DashServerApiResponse<Element[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Element.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<Element[]>>(new DashServerApiResponse(status, _headers, null as any));
    }

    components(): Observable<DashServerApiResponse<Component[]>> {
        let url_ = this.baseUrl + "/api/Element/components";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processComponents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processComponents(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<Component[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<Component[]>>;
        }));
    }

    protected processComponents(response: HttpResponseBase): Observable<DashServerApiResponse<Component[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Component.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<Component[]>>(new DashServerApiResponse(status, _headers, null as any));
    }
}

export interface IDashServerPinboard {
    newId(): Observable<DashServerApiResponse<string>>;
    list(): Observable<DashServerApiResponse<Information[]>>;
    delete(ids: string[]): Observable<DashServerApiResponse<FileResponse>>;
    save(data: Information): Observable<DashServerApiResponse<FileResponse>>;
    listInfoItems(): Observable<DashServerApiResponse<Information[]>>;
    get(id: string): Observable<DashServerApiResponse<Information>>;
}

@Injectable()
export class DashServerPinboard implements IDashServerPinboard {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DASH_SERVER_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    newId(): Observable<DashServerApiResponse<string>> {
        let url_ = this.baseUrl + "/api/Pinboard/newId";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<string>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<string>>;
        }));
    }

    protected processNewId(response: HttpResponseBase): Observable<DashServerApiResponse<string>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<string>>(new DashServerApiResponse(status, _headers, null as any));
    }

    list(): Observable<DashServerApiResponse<Information[]>> {
        let url_ = this.baseUrl + "/api/Pinboard";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processList(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<Information[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<Information[]>>;
        }));
    }

    protected processList(response: HttpResponseBase): Observable<DashServerApiResponse<Information[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Information.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<Information[]>>(new DashServerApiResponse(status, _headers, null as any));
    }

    delete(ids: string[]): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Pinboard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(ids);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    save(data: Information): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/Pinboard";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSave(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSave(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processSave(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    listInfoItems(): Observable<DashServerApiResponse<Information[]>> {
        let url_ = this.baseUrl + "/api/Pinboard/list";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processListInfoItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processListInfoItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<Information[]>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<Information[]>>;
        }));
    }

    protected processListInfoItems(response: HttpResponseBase): Observable<DashServerApiResponse<Information[]>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Information.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<Information[]>>(new DashServerApiResponse(status, _headers, null as any));
    }

    get(id: string): Observable<DashServerApiResponse<Information>> {
        let url_ = this.baseUrl + "/api/Pinboard/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<Information>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<Information>>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DashServerApiResponse<Information>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Information.fromJS(resultData200);
            return _observableOf(new DashServerApiResponse(status, _headers, result200));
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<Information>>(new DashServerApiResponse(status, _headers, null as any));
    }
}

export interface IDashServerUser {
    login(user: User): Observable<DashServerApiResponse<FileResponse>>;
    updatePassword(user: User): Observable<DashServerApiResponse<FileResponse>>;
    logout(): Observable<DashServerApiResponse<FileResponse>>;
}

@Injectable()
export class DashServerUser implements IDashServerUser {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(DASH_SERVER_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    login(user: User): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/User/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    updatePassword(user: User): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/User/Password/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(user);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processUpdatePassword(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }

    logout(): Observable<DashServerApiResponse<FileResponse>> {
        let url_ = this.baseUrl + "/api/User/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashServerApiResponse<FileResponse>>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashServerApiResponse<FileResponse>>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<DashServerApiResponse<FileResponse>> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf(new DashServerApiResponse(status, _headers, { fileName: fileName, data: responseBlob as any, status: status, headers: _headers }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DashServerApiResponse<FileResponse>>(new DashServerApiResponse(status, _headers, null as any));
    }
}

export class Calendar implements ICalendar {
    id?: string;
    prodId!: string;
    name!: string;
    hexColor!: string;
    version!: string;
    events?: CalendarEvent[];

    constructor(data?: ICalendar) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.prodId = _data["prodId"];
            this.name = _data["name"];
            this.hexColor = _data["hexColor"];
            this.version = _data["version"];
            if (Array.isArray(_data["events"])) {
                this.events = [] as any;
                for (let item of _data["events"])
                    this.events!.push(CalendarEvent.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Calendar {
        data = typeof data === 'object' ? data : {};
        let result = new Calendar();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["prodId"] = this.prodId;
        data["name"] = this.name;
        data["hexColor"] = this.hexColor;
        data["version"] = this.version;
        if (Array.isArray(this.events)) {
            data["events"] = [];
            for (let item of this.events)
                data["events"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICalendar {
    id?: string;
    prodId: string;
    name: string;
    hexColor: string;
    version: string;
    events?: CalendarEvent[];
}

export class CalendarEvent implements ICalendarEvent {
    id?: string;
    uid!: string;
    location?: string | undefined;
    summary?: string | undefined;
    description?: string | undefined;
    class?: string;
    dtStart!: Date;
    dtEnd!: Date;
    dtStamp!: Date;
    calendarId!: string;
    calendar?: Calendar;

    constructor(data?: ICalendarEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.uid = _data["uid"];
            this.location = _data["location"];
            this.summary = _data["summary"];
            this.description = _data["description"];
            this.class = _data["class"];
            this.dtStart = _data["dtStart"] ? new Date(_data["dtStart"].toString()) : <any>undefined;
            this.dtEnd = _data["dtEnd"] ? new Date(_data["dtEnd"].toString()) : <any>undefined;
            this.dtStamp = _data["dtStamp"] ? new Date(_data["dtStamp"].toString()) : <any>undefined;
            this.calendarId = _data["calendarId"];
            this.calendar = _data["calendar"] ? Calendar.fromJS(_data["calendar"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CalendarEvent {
        data = typeof data === 'object' ? data : {};
        let result = new CalendarEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["uid"] = this.uid;
        data["location"] = this.location;
        data["summary"] = this.summary;
        data["description"] = this.description;
        data["class"] = this.class;
        data["dtStart"] = this.dtStart ? this.dtStart.toISOString() : <any>undefined;
        data["dtEnd"] = this.dtEnd ? this.dtEnd.toISOString() : <any>undefined;
        data["dtStamp"] = this.dtStamp ? this.dtStamp.toISOString() : <any>undefined;
        data["calendarId"] = this.calendarId;
        data["calendar"] = this.calendar ? this.calendar.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICalendarEvent {
    id?: string;
    uid: string;
    location?: string | undefined;
    summary?: string | undefined;
    description?: string | undefined;
    class?: string;
    dtStart: Date;
    dtEnd: Date;
    dtStamp: Date;
    calendarId: string;
    calendar?: Calendar;
}

export class CalendarRequest implements ICalendarRequest {
    name!: string;
    color!: string;

    constructor(data?: ICalendarRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.color = _data["color"];
        }
    }

    static fromJS(data: any): CalendarRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CalendarRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["color"] = this.color;
        return data;
    }
}

export interface ICalendarRequest {
    name: string;
    color: string;
}

export class CalendarEventRequest implements ICalendarEventRequest {
    location?: string | undefined;
    summary?: string | undefined;
    description?: string | undefined;
    dtStart!: Date;
    dtEnd!: Date;
    calendarId!: string;

    constructor(data?: ICalendarEventRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.location = _data["location"];
            this.summary = _data["summary"];
            this.description = _data["description"];
            this.dtStart = _data["dtStart"] ? new Date(_data["dtStart"].toString()) : <any>undefined;
            this.dtEnd = _data["dtEnd"] ? new Date(_data["dtEnd"].toString()) : <any>undefined;
            this.calendarId = _data["calendarId"];
        }
    }

    static fromJS(data: any): CalendarEventRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CalendarEventRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location;
        data["summary"] = this.summary;
        data["description"] = this.description;
        data["dtStart"] = this.dtStart ? this.dtStart.toISOString() : <any>undefined;
        data["dtEnd"] = this.dtEnd ? this.dtEnd.toISOString() : <any>undefined;
        data["calendarId"] = this.calendarId;
        return data;
    }
}

export interface ICalendarEventRequest {
    location?: string | undefined;
    summary?: string | undefined;
    description?: string | undefined;
    dtStart: Date;
    dtEnd: Date;
    calendarId: string;
}

export class Display implements IDisplay {
    displayId?: string;
    name?: string | undefined;
    icon?: string | undefined;
    description?: string | undefined;
    rows!: number;
    columns!: number;
    shareId!: string;
    elements?: Element[];

    constructor(data?: IDisplay) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayId = _data["displayId"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.description = _data["description"];
            this.rows = _data["rows"];
            this.columns = _data["columns"];
            this.shareId = _data["shareId"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(Element.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Display {
        data = typeof data === 'object' ? data : {};
        let result = new Display();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayId"] = this.displayId;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["description"] = this.description;
        data["rows"] = this.rows;
        data["columns"] = this.columns;
        data["shareId"] = this.shareId;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDisplay {
    displayId?: string;
    name?: string | undefined;
    icon?: string | undefined;
    description?: string | undefined;
    rows: number;
    columns: number;
    shareId: string;
    elements?: Element[];
}

export class Element implements IElement {
    elementId?: string;
    config!: string;
    content?: string | undefined;
    creationDate!: Date;
    expireDate?: Date | undefined;
    componentId!: string;
    component?: Component;
    displayId!: string;
    display?: Display;

    constructor(data?: IElement) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.elementId = _data["elementId"];
            this.config = _data["config"];
            this.content = _data["content"];
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
            this.componentId = _data["componentId"];
            this.component = _data["component"] ? Component.fromJS(_data["component"]) : <any>undefined;
            this.displayId = _data["displayId"];
            this.display = _data["display"] ? Display.fromJS(_data["display"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Element {
        data = typeof data === 'object' ? data : {};
        let result = new Element();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["elementId"] = this.elementId;
        data["config"] = this.config;
        data["content"] = this.content;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["componentId"] = this.componentId;
        data["component"] = this.component ? this.component.toJSON() : <any>undefined;
        data["displayId"] = this.displayId;
        data["display"] = this.display ? this.display.toJSON() : <any>undefined;
        return data;
    }
}

export interface IElement {
    elementId?: string;
    config: string;
    content?: string | undefined;
    creationDate: Date;
    expireDate?: Date | undefined;
    componentId: string;
    component?: Component;
    displayId: string;
    display?: Display;
}

export class Component implements IComponent {
    id?: string;
    identifier!: string;
    name!: string;
    image?: string | undefined;
    config!: string;
    elements?: Element[];

    constructor(data?: IComponent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.identifier = _data["identifier"];
            this.name = _data["name"];
            this.image = _data["image"];
            this.config = _data["config"];
            if (Array.isArray(_data["elements"])) {
                this.elements = [] as any;
                for (let item of _data["elements"])
                    this.elements!.push(Element.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Component {
        data = typeof data === 'object' ? data : {};
        let result = new Component();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["identifier"] = this.identifier;
        data["name"] = this.name;
        data["image"] = this.image;
        data["config"] = this.config;
        if (Array.isArray(this.elements)) {
            data["elements"] = [];
            for (let item of this.elements)
                data["elements"].push(item.toJSON());
        }
        return data;
    }
}

export interface IComponent {
    id?: string;
    identifier: string;
    name: string;
    image?: string | undefined;
    config: string;
    elements?: Element[];
}

export class ElementRequest implements IElementRequest {
    config!: string;
    content?: string | undefined;
    expireDate?: Date | undefined;
    componentId!: string;
    displayId!: string;

    constructor(data?: IElementRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.config = _data["config"];
            this.content = _data["content"];
            this.expireDate = _data["expireDate"] ? new Date(_data["expireDate"].toString()) : <any>undefined;
            this.componentId = _data["componentId"];
            this.displayId = _data["displayId"];
        }
    }

    static fromJS(data: any): ElementRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ElementRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["config"] = this.config;
        data["content"] = this.content;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["componentId"] = this.componentId;
        data["displayId"] = this.displayId;
        return data;
    }
}

export interface IElementRequest {
    config: string;
    content?: string | undefined;
    expireDate?: Date | undefined;
    componentId: string;
    displayId: string;
}

export class Information implements IInformation {
    id?: string;
    name!: string;
    text?: string | undefined;
    image?: string | undefined;
    creationDate?: Date;
    expiredDate?: Date | undefined;
    isFocused?: boolean;
    config?: string | undefined;

    constructor(data?: IInformation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.text = _data["text"];
            this.image = _data["image"];
            this.creationDate = _data["creationDate"] ? new Date(_data["creationDate"].toString()) : <any>undefined;
            this.expiredDate = _data["expiredDate"] ? new Date(_data["expiredDate"].toString()) : <any>undefined;
            this.isFocused = _data["isFocused"];
            this.config = _data["config"];
        }
    }

    static fromJS(data: any): Information {
        data = typeof data === 'object' ? data : {};
        let result = new Information();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["text"] = this.text;
        data["image"] = this.image;
        data["creationDate"] = this.creationDate ? this.creationDate.toISOString() : <any>undefined;
        data["expiredDate"] = this.expiredDate ? this.expiredDate.toISOString() : <any>undefined;
        data["isFocused"] = this.isFocused;
        data["config"] = this.config;
        return data;
    }
}

export interface IInformation {
    id?: string;
    name: string;
    text?: string | undefined;
    image?: string | undefined;
    creationDate?: Date;
    expiredDate?: Date | undefined;
    isFocused?: boolean;
    config?: string | undefined;
}

export class User implements IUser {
    name?: string;
    password?: string;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["password"] = this.password;
        return data;
    }
}

export interface IUser {
    name?: string;
    password?: string;
}

export class DashServerApiResponse<TResult> {
    status: number;
    headers: { [key: string]: any; };
    result: TResult;

    constructor(status: number, headers: { [key: string]: any; }, result: TResult)
    {
        this.status = status;
        this.headers = headers;
        this.result = result;
    }
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class DashServerApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isDashServerApiException = true;

    static isDashServerApiException(obj: any): obj is DashServerApiException {
        return obj.isDashServerApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new DashServerApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}